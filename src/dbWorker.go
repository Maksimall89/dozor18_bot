package src

import (
	"context"
	"fmt"
	"github.com/jackc/pgx/v4/pgxpool"
	"log"
	"strings"
)

func (confDataBase DataBase) DBInsertCodesUsers() {
	dbpool, err := pgxpool.Connect(context.Background(), confDataBase.DBURL)
	if err != nil {
		log.Printf("Unable to connect to database: %v\n", err)
	}
	defer dbpool.Close()

	_, err = dbpool.Query(context.Background(), "INSERT INTO CodesUser (Time, NickName,  Code, Danger, Sector) VALUES ($1, $2, $3, $4, $5)",
		confDataBase.Time, confDataBase.NickName, confDataBase.Code, confDataBase.Danger, confDataBase.Sector)
	if err != nil {
		log.Println(err)
	}
}
func (confDataBase *DataBase) DBInsertCodesRight(addData string) string {
	strArr := strings.Split(addData, ",")
	if len(strArr) < 3 {
		return "Слишком короткая строка: /add Code,Danger,Sector"
	}

	dbpool, err := pgxpool.Connect(context.Background(), confDataBase.DBURL)
	if err != nil {
		return fmt.Sprintf("Unable to connect to database: %v\n", err)
	}
	defer dbpool.Close()

	_, err = dbpool.Query(context.Background(), "INSERT INTO CodesRight (Code, Danger, Sector) VALUES ($1, $2, $3)",
		strings.TrimSpace(strArr[0]), strings.TrimSpace(strArr[1]), strings.TrimSpace(strArr[2]))
	if err != nil {
		return fmt.Sprintf("Unable to INSERT INTO CodesRight: %v\n", err)
	}

	return "&#10004;Данные <b>добавлены</b> в БД."
}
func (confDataBase *DataBase) DBDeleteCodesRight(deleteStr string) string {
	if len(deleteStr) < 2 {
		return "Слишком короткая строка: /delete CodeOld"
	}

	dbpool, err := pgxpool.Connect(context.Background(), confDataBase.DBURL)
	if err != nil {
		return fmt.Sprintf("Unable to connect to database: %v\n", err)
	}
	defer dbpool.Close()

	_, err = dbpool.Query(context.Background(), "DELETE FROM CodesRight WHERE Code = $1", deleteStr)
	if err != nil {
		return fmt.Sprintf("Unable to DELETE CodesRight: %v\n", err)
	}

	return "&#8252;Данные <b>удалены</b> в БД=" + deleteStr
}
func (confDataBase *DataBase) DBUpdateCodesRight(updateData string) string {
	strArr := strings.Split(updateData, ",")
	if len(strArr) < 4 {
		return "Нет всех аргументов: /update CodeNew,Danger,Sector,CodeOld"
	}

	dbpool, err := pgxpool.Connect(context.Background(), confDataBase.DBURL)
	if err != nil {
		return fmt.Sprintf("Unable to connect to database: %v\n", err)
	}
	defer dbpool.Close()

	_, err = dbpool.Query(context.Background(), "UPDATE CodesRight SET Code = $1, Danger = $2, Sector=$3 WHERE Code = $4",
		strings.TrimSpace(strArr[0]), strArr[1], strArr[2], strings.TrimSpace(strArr[3]))
	if err != nil {
		return fmt.Sprintf("Unable to UPDATE CodesRight: %v\n", err)
	}

	return "&#10071;Данные <b>обновлены</b> в БД."
}
func (confDataBase *DataBase) DBSelectCodes() []DataBase {
	dbpool, err := pgxpool.Connect(context.Background(), confDataBase.DBURL)
	if err != nil {
		fmt.Printf("Unable to connect to database: %v\n", err)
	}
	defer dbpool.Close()

	rows, err := dbpool.Query(context.Background(), "SELECT Time, Code FROM CodesUser WHERE NickName = $1", confDataBase.NickName)
	if err != nil {
		log.Println(err)
	}

	var data []DataBase
	for rows.Next() {
		d := DataBase{}
		err := rows.Scan(&d.Time, &d.Code)
		if err != nil {
			log.Println(err)
			continue
		}
		data = append(data, d)
	}

	return data
}
func (confDataBase *DataBase) DBResetAll() (str string) {
	dbpool, err := pgxpool.Connect(context.Background(), confDataBase.DBURL)
	if err != nil {
		return fmt.Sprintf("Unable to connect to database: %v\n", err)
	}
	defer dbpool.Close()

	// delete table
	_, err = dbpool.Query(context.Background(), "DROP TABLE IF EXISTS CodesUser")
	if err != nil {
		str += fmt.Sprintf("ERROR delete CodeUser: %s", err)
	}
	_, err = dbpool.Query(context.Background(), "DROP TABLE IF EXISTS CodesRight")
	if err != nil {
		str += fmt.Sprintf("ERROR delete CodesRight: %s", err)
	}

	// create table
	_, err = dbpool.Query(context.Background(), "CREATE TABLE "+
		"CodesUser( "+
		"Number integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,"+
		"Time    varchar(40) NOT NULL,"+
		"NickName    varchar(100) NOT NULL,"+
		"Code    varchar(300) NOT NULL,"+
		"Danger   varchar(30) NOT NULL,"+
		"Sector   varchar(100) NOT NULL);")
	if err != nil {
		str += fmt.Sprintf("ERROR create CodesUser: %s", err)
	}
	_, err = dbpool.Query(context.Background(), "CREATE TABLE "+
		"CodesRight("+
		"Number integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,"+
		"Code    varchar(300) NOT NULL,"+
		"Danger   varchar(30) NOT NULL,"+
		"Sector   varchar(100) NOT NULL);")

	if err != nil {
		str += fmt.Sprintf("ERROR create CodesRight: %s", err)
	}
	str += "\n\n&#9940;БД удалены и созданы занова!"

	_, err = dbpool.Query(context.Background(), "CREATE INDEX ON CodesUser(NickName text_pattern_ops);")
	if err != nil {
		str += fmt.Sprintf("ERROR create index: %s", err)
	}
	str += "\n\n&#9940;Индекс NickName в БД CodesUser создан!"

	return str
}
func (confDataBase *DataBase) DBSelectAllCodesRight() []DataBase {
	dbpool, err := pgxpool.Connect(context.Background(), confDataBase.DBURL)
	if err != nil {
		log.Printf("Unable to connect to database: %v\n", err)
	}
	defer dbpool.Close()

	rows, err := dbpool.Query(context.Background(), "SELECT Number, Code, Danger, Sector FROM CodesRight")
	if err != nil {
		log.Printf("Unable to UPDATE CodesRight: %v\n", err)
	}

	var data []DataBase
	for rows.Next() {
		d := DataBase{}
		err := rows.Scan(&d.Number, &d.Code, &d.Danger, &d.Sector)
		if err != nil {
			log.Println(err)
			continue
		}
		data = append(data, d)
	}

	return data
}
func (confDataBase *DataBase) DBSelectAllCodesUser() []DataBase {
	dbpool, err := pgxpool.Connect(context.Background(), confDataBase.DBURL)
	if err != nil {
		log.Printf("Unable to connect to database: %v\n", err)
	}
	defer dbpool.Close()

	rows, err := dbpool.Query(context.Background(), "SELECT Number, Time, NickName, Code, Danger, Sector FROM CodesUser")
	if err != nil {
		log.Printf("Unable to UPDATE CodesRight: %v\n", err)
	}

	var data []DataBase
	for rows.Next() {
		d := DataBase{}
		err := rows.Scan(&d.Number, &d.Time, &d.NickName, &d.Code, &d.Danger, &d.Sector)
		if err != nil {
			log.Println(err)
			continue
		}
		data = append(data, d)
	}

	return data
}
